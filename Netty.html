<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 9.1.0 (458321)"/><meta name="author" content="lan_tp@126.com"/><meta name="created" content="2020-04-24 01:35:57 +0000"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2020-06-06 08:10:05 +0000"/><title>Netty</title></head><body><ol><li><div>DelimiterBasedFrameDecoder 分隔符解码器</div></li><ol><li><div>该解码器有多个构造方法，其中两个主要的参数，第一个可用于表示单条消息的最大长度，当达到该长度后依然没有查找到分隔符，就抛出TooLongFrameException异常，防止出现内存溢出。第二个参数是分隔符缓冲对象用来作为消息分割的。</div><div>// 表示用 $_ 作为分隔符</div><div>ByteBuf delimiter = Unpooled.copiedBuffer(“$_”)</div><div>new DelimiterBasedFrameDecoder(1024,delimiter)</div></li></ol><li><div>FixedLengthFrameDecoder 固定长度解码器</div></li><li><div>MessageToMessageEncoder</div></li><ol><li><div>通常用于对消息对象进行编码</div><div>如StompSubframeEncoder extends MessageToMessageEncoder&lt;StompSubframe&gt; {</div><div>         Public void encode(ChannelHandlerContext ctx,StompSubframe msg, List&lt;Object&gt; out&gt; {}</div><div>   }</div></li></ol><li><div>SimpleChannelInboundHandler</div></li><ol><li><div>通常可直接用户对接收的对象进行处理，复写channelRead0(ChannelHandlerContext ctx, T msg)方法</div><div>TelnetClientHandler extends SimpleChannelInboundHandler&lt;String&gt; {</div><div>        Void channelRead0(ChannelHandlerContext ctx,String msg) {</div><div>        }</div><div>}</div></li></ol><li><div>Netty 实现零拷贝</div></li><ol><li><div>CompositeByteBuf</div><div>假设有一份协议数据，它由头部和消息体组成，而头部和消息体是分别存放在两个ByteBuf中的，如果创建第三个ByteBuf，则需要额外对其他两个ByteBuf进行复制，造成不必要的复制。</div><div>如果使用CompositeByteBuf，则可以如下操作，减少不必要的复制拷贝。</div><div>ByteBuf header = ……</div><div>ByteBuf body = ……</div><div>CompositeByteBuf compositeByteBuf = <a href="http://unpooled.compositebuffer();/">Unpooled.compositeBuffer();</a></div><div>compositeByteBuf.addComponents(true, header, body);</div></li><li><div>通过wrap 实现零拷贝</div><div>假设有一byte数组，希望将其转化为ByteBuf对象，传统做法是将byte数组拷贝到ByteBuf中，但其实造成了不必要的拷贝。</div><div>byte[] bytes = ……</div><div>ByteBuf byteBuf = Unpooled.wrappedBuffer(bytes);</div></li><li><div>通过slice 实现零拷贝</div><div>与wrap操作相反，将一个ByteBuf切片为多个共享一个存储区域的ByteBuf对象。</div></li><li><div>通过FileRegion 实现零拷贝</div><div>netty使用FileRegion实现文件传输的零拷贝，底层依赖 FileChannel.transfer的零拷贝功能。</div></li></ol><li><div>直接缓冲区</div></li><ol><li><div>在堆之外分配内存，不会占用堆空间容量。</div></li><li><div>分配内存和释放内存比堆缓冲区复杂，因此建议使用缓冲池。</div></li><li><div>不支持数组访问数据，因此不能调用类似 directBuf.hasArrary等类似操作。</div></li></ol><li><div>ChannelFuture &amp; ChannelPromise</div></li><ol><li><div>netty自己的Future 和 Promise接口都是继承自jdk的future接口；</div></li><li><div>future的接口主要是增加了addListener 和 removeListener接口；</div></li><li><div>Promise主要是在Future接口的基础上增加了对操作结果设置；</div><div><br/></div></li></ol></ol><div><br/></div></body></html>